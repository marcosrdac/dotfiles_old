# interpreter for shell commands (needs to be POSIX compatible)
set shell sh
# shell behaviour
set shellopts '-e'
# internal filed separator
set ifs "\n"
# find stops when there is only one file left
set findlen 0
# borders around
set drawbox=false
# show hiden files
set hidden=false
# scrll before selecting end of list
set scrolloff 8
# show icons
set icons=false
# ignore case
set ignorecase true
# custom previewer script to be used
#set previewer ""
# numbering files
set number
set relativenumber


# Unmap the default mappings
map r
map <space>
map f
map d
map y
map v
map u
map c
map a


# mappings
map f find
# use enter for shell commands
map <enter> open
# execute current file (must be executable)
map x $$f
map X !$f
# file selection
map <space> toggle
map v unselect
map V invert
map U clear
# file manipulation
map yy copy
map dd cut
map p paste
map DD       trash
map <delete> trash
map u trash-restore
# copying paths
map yf %lf -remote "send $id copy_path --path"
map yd %lf -remote "send $id copy_path --directory"
map yn %lf -remote "send $id copy_path --filename"
# renaming
#map cW &lf -remote "send $id push :rename<space>"
#map C  &lf -remote "send $id push :rename<space>"
#map cw &lf -remote "send $id push :rename<space>-n<space>"
#map A  &lf -remote "send $id push $(echo ":rename $(basename $f)" | sed 's/\s/<space>/g')"
#map a  &fn=$(basename $f | sed 's/\s/<space>/g') && [ $(echo $fn | grep "\." 2>/dev/null) ] && fn="${fn%.*}" && lf -remote "send $id push :rename<space>-n<space>$fn" || lf -remote "send $id push :rename<space>$fn"
#map I  &fn=$(basename $f | sed 's/\s/<space>/g') && lf -remote "send $id push :rename<space>$fn<home><right><right><right><right><right><right><right>"
map cW &lf -remote "send $id push :" && lf -remote "send $id push $(echo "rename " | sed 's/\s/<space>/g')"
map C  &lf -remote "send $id push :" && lf -remote "send $id push $(echo "rename " | sed 's/\s/<space>/g')"
#map cw &lf -remote "send $id push :" && lf -remote "send $id push $(echo "rename -n " | sed 's/\s/<space>/g')"
map cw &lf -remote "send $id push :" && fn=$(basename $f) && ext="${fn##*.}" && go_back=0 && [ $(echo $fn | grep "\." 2>/dev/null) ] && go_back=$(echo "$ext" | wc -c) && fn="" && ext=".$ext" || ext=""; fn=$(printf "$ext" && awk 'BEGIN{for(c=0;c<'$go_back';c++) printf "<left>"}') && lf -remote "send $id push $(echo "rename $fn" | sed 's/\s/<space>/g')"
map A  &lf -remote "send $id push :" && lf -remote "send $id push $(echo "rename $(basename $f)" | sed 's/\s/<space>/g')"
map I  &lf -remote "send $id push :" && lf -remote "send $id push $(echo "rename $(basename $f)" | sed 's/\s/<space>/g')" && lf -remote "send $id push $(echo "<home>lllllll" | sed 's/l/<right>/g')"
map a  &lf -remote "send $id push :" && fn=$(basename $f) && ext="${fn##*.}" && go_back=0 && [ $(echo $fn | grep "\." 2>/dev/null) ] && go_back=$(echo "$ext" | wc -c); fn=$(printf "$fn" && awk 'BEGIN{for(c=0;c<'$go_back';c++) printf "<left>"}') && lf -remote "send $id push $(echo "rename $fn" | sed 's/\s/<space>/g')"

map <c-r> recol

cmd recol %{{
  w=$(tput cols)
  if [ $w -le 35 ]
  then
    lf -remote "send $id set nopreview"
    lf -remote "send $id set ratios 1"
  else
    lf -remote "send $id set preview"
    if [ $w -le 80 ]
    then
      lf -remote "send $id set ratios 2:3"
    elif [ $w -le 160 ]
    then
      lf -remote "send $id set ratios 2:3:5"
    else
      lf -remote "send $id set ratios 2:3:5:8"
    fi
  fi
}}
recol


cmd copy_path %{{
  case $1 in
    --path)      path="$fx" && shift ;;
    --directory) path="$(dirname  "$fx")" && shift ;;
    --filename)  path="$(basename "$fx")" && shift ;;
    *) exit 1;
  esac
  echo $path | xclip -i -selection clipboard -f | xclip -i -selection primary &&
  echo "Copied: "$fx"."
  exit 0
}}

cmd setwallpaper %{{
  wal_set $f
}}

cmd mkdir %{{
  base="$(dirname "$f")"

  if [ $# -lt 1 ]
  then
    printf "Folder name: "
    read ans
    set $ans
  fi

  for folder_name in "$@"
  do
    mkdir -p $base/$folder_name
  done

  [ $# -ne 1 ] && ies=ies || ies=y
  echo "Director$ies created: $@"
}}

cmd touch %{{
  base="$(dirname "$f")"

  if [ $# -lt 1 ]
  then
    printf "Folder name: "
    read ans
    set $ans
  fi

  for file_name in "$@"
  do
    touch $base/$file_name
  done

  [ $# -ne 1 ] && s=s || s=''
  echo "File$s created: $@"
}}

cmd q %{{
  lf -remote "send $id quit"
}}


# rename functions

cmd rename %{{
  base="$(dirname "$f")"
  srcfn=$(basename -- "$f")
  srcext="${srcfn##*.}"
  srcfn="$(basename "$f" ".$srcext")"
  srcdot="" && [ ! -z $srcext ] && srcdot="."

  filename_only="" ; extension_only=""
  case $1 in
    -n)
      filename_only=true && shift
      dst="$base/$@$srcdot$srcext" ;;
    -e)
      extension_only=true && shift
      dst="$base/$srcfn$srcdot$@" ;;
    *) dst="$base/$@" ;;
  esac

  [ $# -eq 0 ] && echo "Destination not given." && exit 1
  [ -e "$dst" ] && printf "  Not renamed: "$dst" exists." || mv $f $dst
}}


### rename various files at once with editor
#cmd bulk-rename ${{
#  old_names=$(mktemp /tmp/lf-bulk-old.XXXXXXXXXX)
#  new_names=$(mktemp /tmp/lf-bulk-new.XXXXXXXXXX)
#  dirnames=$(mktemp  /tmp/lf-bulk-dirs.XXXXXXXXXX)
#  if [ -n "$fs" ]
#  then
#    index="$fs"
#  else
#    index="$(ls $(dirname "$f"))"
#  fi
#
#  for filename in $index
#  do
#    echo $(basename "$filename") >> $old_names
#    echo $(dirname  "$filename") >> $dirnames
#  done
#  cp $old_names $new_names
#  $EDITOR $new_names
#
#  n=$(cat $old_names | wc -l)
#  if [ $(cat $new_names | wc -l) -eq $n ]
#  then
#    please='' && [ ! -w . ] && please='sudo'
#    counter=1
#    while [ $counter -le $((n+1)) ]
#    do
#      old="$(cat $old_names | sed "${counter}q;d")"
#      new="$(cat $new_names | sed "${counter}q;d")"
#      dir="$(cat $dirnames  | sed "${counter}q;d")"
#      counter=$(($counter+1))
#      [ "$old" = "$new" ] && continue
#      [ -e "$new" ] && echo "File exists: $b" && continue
#      $please mv "$dir/$old" "$dir/$new"
#    done
#  else
#    echo "Number of filenames differ."
#  fi
#  echo $new_names
#  #rm $index $index_edit
#}}


## rename various files at once with editor
cmd bulk-rename ${{
  case $1 in
    -n) mode="no-exts" ;;
    -e) mode="only-exts" ;;
    -A) mode="all-path" ;;
  esac

  oldnames=$(mktemp /tmp/lf-bulk-oldnames.XXXXXXXXXX)
  newnames=$(mktemp /tmp/lf-bulk-newnames.XXXXXXXXXX)
  dirnames=$(mktemp /tmp/lf-bulk-dirnames.XXXXXXXXXX)
  aux=$(mktemp /tmp/lf-bulk-aux.XXXXXXXXXX)

  if [ -n "$fs" ]
  then
    index="$fs"
  else
    index="$(ls $(dirname "$f"))"
  fi

  for path in $index
  do
    dir="$(dirname "$path")"
    fullfilename=$(basename -- "$path")
    filename="${fullfilename%.*}"  # must be here
    ext="" && [ $(echo $fullfilename | grep "\." 2>/dev/null) ] && ext="${fullfilename##*.}"

    [ "$mode" != "all-path" ] && echo $dir >> $dirnames
    [ "$mode" = "" ]          && echo $fullfilename >> $oldnames
    [ "$mode" = "all-path" ]  && echo $(realpath $path) >> $oldnames
    if [ "$mode" = "no-exts" ]
    then
      echo $filename >> $oldnames
      [ "$ext" != "" ] && echo ".$ext" >> $aux || echo "" >> $aux
    fi
    [ "$mode" = "only-exts" ] && echo $ext >> $oldnames && echo $filename >> $aux
    #echo $dir $fullfilename $filename $ext
  done
  cp $oldnames $newnames
  $EDITOR $newnames

  n=$(cat $oldnames | wc -l)
  if [ $(cat $newnames | wc -l) -eq $n ]
  then
    please='' && [ ! -w . ] && please='sudo'  # adjust it
    counter=1
    while [ $counter -le $((n+1)) ]
    do
      case $mode in
        "no-exts")
          dir="$(cat $dirnames | sed "${counter}q;d")"
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          ext="$(cat $aux      | sed "${counter}q;d")"
          old="$dir/$old$ext" ; new="$dir/$new$ext"
        ;;
        "all-path")
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
        ;;
        "only-exts")
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          filename="$(cat $aux | sed "${counter}q;d")"
          echo $old $new
          [ "$old" != "" ] && old=".$old"
          [ "$new" != "" ] && new=".$new"
          old="$dir/$filename$old"
          new="$dir/$filename$new"
        ;;
        *)
          dir="$(cat $dirnames | sed "${counter}q;d")"
          old="$(cat $oldnames | sed "${counter}q;d")"
          new="$(cat $newnames | sed "${counter}q;d")"
          old="$dir/$old" ; new="$dir/$new"
        ;;
      esac
      counter=$(($counter+1))
      [ "$old" = "$new" ] && continue
      [ -e "$new" ] && echo "File exists: $b" && continue
      $please mv "$dir/$old" "$dir/$new"
    done
  else
    echo "Number of filenames differ."
  fi
  rm $oldnames $newnames $dirnames $aux
}}


cmd paste-symlink ${{
  load=$(lf -remote 'load')
  mode=$(echo "$load" | sed -n '1p')
  list=$(echo "$load" | sed '1d')
  if [ $mode = 'copy' ]; then
    s='' && [ ! -w . ] && s='sudo'
    for f in $list; do
      $s ln -s "$f" "$(pwd)/$(basename $f)"
    done
    lf -remote 'send load'
    lf -remote 'send clear'
  fi
}}


# pasting done right
cmd paste %{{
    send="while read -r line; do lf -remote \"send $id echo \$line\"; done && lf -remote 'send reload'"
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    srcF=$(mktemp)
    echo "$load" | sed '1d' > "$srcF"
    please='' && [ ! -w . ] && please='sudo'
    case "$mode" in
        copy) cmd='cp-p';;
        move) cmd='mv-p';;
    esac
    cmd="$cmd --new-line"
    $please sh -c "$cmd --backup=numbered -F \"$srcF\" . | $send && rm -f \"$srcF\" &"
    lf -remote 'send load'
    lf -remote 'send clear'
}}

# assynchronous pasting
cmd paste-async &{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]
    then
        cp -rn $list .
    elif [ $mode = 'move' ]
    then
        mv -n $list .
    fi
    lf -remote 'send load'
    lf -remote 'send clear'
}}


# trash-cli commands
cmd trash   % trash-put $fx
cmd restore $ trash-restore
cmd empty   % trash-empty


# dealing with compacted data

# extract the current file with the right command
cmd extract ${{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f ;;
        *.tar.gz|*.tgz) tar xzvf $f ;;
        *.tar.xz|*.txz) tar xJvf $f ;;
        *.zip) unzip $f ;;
        *.rar) unrar x $f ;;
        *.7z) 7z x $f ;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}


# Open command #

cmd open ${{
    case $(file --mime-type $f -b) in
        text/*) $EDITOR $fx;;
        *) for f in $fx; do setsid $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f
