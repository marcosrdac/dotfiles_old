#!/usr/bin/env sh

# TO DO: substitute

TRASH_DIR=${TRASH:-"$XDG_DATA_HOME/Trash"}
TRASH_FILES=${TRASH_DIR:-"$XDG_DATA_HOME/Trash"}/files
TRASH_INFO=${TRASH:-"$XDG_DATA_HOME/Trash"}/info
[ -e $TRASH_FILES ] || mkdir -p $TRASH_FILES
[ -e $TRASH_INFO ] || mkdir -p $TRASH_INFO
INFOEXT=".tsv"
IFS=$'\n'


trash_put () {
  [ $# -lt 1 ] && echo "No path given as argument." && exit 1
  for filepath in $@
  do
    src=$(realpath "$filepath")
    [ ! -e "$src" ] && echo "\"$filepath\" does not exist." && exit 1
    basesrc=$(basename "$filepath")
    # get last trash id to calculate the new one's
    lastid="$(ls $TRASH_INFO | egrep -o '^[0-9]+' | sort -g | tail -n 1)"
    [ -z "$lastid" ] && id=0 || id=$((lastid+1))
    trash="$TRASH_FILES/${id}_${basesrc}"
    infofile="$TRASH_INFO/${id}_${basesrc}$INFOEXT"
    info="SOURCE_PATH\t$src\nTRASH_PATH\t$trash"
    please='' && [ ! -w "$filepath" ] && please='sudo'
    $please mv $src $trash &&
    echo -e "$info" > "$infofile"

    if [ $? -eq 0 ]
    then
      echo -e "\"$filepath\" moved to trash with ID: \"$id\"."
    else
      echo -e "Could not trash \"$filepath\"."
      exit 1
    fi
  done
}

trash_empty () {
  infofiles=$(ls $TRASH_INFO | grep "$INFOEXT\$" | sort -gr)
  for infofile in $infofiles
  do
    infofile=$TRASH_INFO/$infofile
    trash="$(cat $infofile | awk -F '\t' '/^TRASH_PATH/ { print $2 }')"
    please='' && [ ! -w "$trash" ] && please='sudo'
    $please rm -rf "$trash" && rm -f "$infofile" ||
      echo "Could not remove \"$filename\"." exit 1
  done
  for path in $(ls -d "$TRASH_FILES"/* && ls -d "$TRASH_INFO"/*)
  do
    notify-send
    please='' && [ ! -w "$path" ] && please='sudo'
    $please rm -rf "$path"
  done
  echo "Trash empty."
}

trash_list () {
  infofiles=$(ls $TRASH_INFO | grep "$INFOEXT\$" | sort -g)
  [ $(echo -e "$infofiles" | wc -w) -gt 0 ] && echo -e "ID\tSOURCE_PATH"
  for infofile in $infofiles
  do
    infofile=$TRASH_INFO/$infofile
    info="$(basename $infofile)"
    id=${info%%_*}
    src=$(cat $infofile | awk -F '\t' '/^SOURCE_PATH/ { print $2 }')
    echo -e "${id}\t${src}"
  done
}

trash_restore_last () {
  [ -z "$1" ] && n=1 || n="$1"
  #restore_list=$(ls -d "$TRASH_INFO"/* | grep "$INFOEXT\$" | sort -g | tail -n $n)
  restore_list=$(ls $TRASH_INFO | grep "$INFOEXT\$" | sort -g | tail -n $n)
  if [ $(echo -n $restore_list | wc -w) -eq 0 ]
  then
    echo "No files in trash." && exit 1
  fi

  atleastonefail=false
  for infofile in $restore_list
  do
    infofile="$TRASH_INFO/$infofile"
    info="$(basename $infofile)"
    id="${info%%_*}"
    src="$(cat $infofile | awk -F '\t' '/^SOURCE_PATH/ { print $2 }')"
    trash="$(cat $infofile | awk -F '\t' '/^TRASH_PATH/ { print $2 }')"
    [ ! -e "$trash" ] && echo "File already removed." &&
      rm $infofile && atleastonefail=true && continue

    dest="$src" && while [ -e "$dest" ]
    do
      dest="$src.bak"
    done

    destdir="$(dirname "$dest")"
    if [ ! -e "$destdir" ]
    then
      echo "Directory does not exist. File restored to \"$HOME\"."
      dest="$HOME/$(basename $dest)"
    fi

    please='' && ([ ! -w "$trash" ] || [ ! -w "$destdir" ]) && please='sudo'
    $please mv -b $trash $dest && rm $infofile

    if [ $? -eq 0 ]
    then
      echo "\"$dest\" restored."
      $atleastonefail && exit 1
    else
      echo "Could not restore \"$dest\" from \"$trash\"." && exit 1
    fi
  done
}

trash_restore () {
  [ -z "$1" ] && echo "No trash ID's given as argument." && exit 1 || id="$1"
  infofiles=$(ls "$TRASH_INFO" | grep "$INFOEXT\$")
  found=false
  for infofile in $infofiles
  do
    infofile="$TRASH_INFO/$infofile"
    info="$(basename $infofile)"
    [ $id -eq ${info%%_*} ] && found=true && break
  done
  ! $found && echo "Could no find such entry number $id." && exit 1
  src="$(cat $infofile | awk -F '\t' '/^SOURCE_PATH/ { print $2 }')"
  trash="$(cat $infofile | awk -F '\t' '/^TRASH_PATH/ { print $2 }')"

  dest="$src" && while [ -e "$dest" ]
  do
    dest="$src.bak"
  done

  destdir="$(dirname "$dest")"
  if [ ! -e "$destdir" ]
  then
    echo "Directory does not exist. Restoring file to \"$HOME\"."
    dest="$HOME/$(basename $dest)"
  fi

  please='' && ([ ! -w "$trash" ] || [ ! -w "$destdir" ]) && please='sudo'
  $please mv -b "$trash" "$dest" && rm "$infofile"

  if [ $? -eq 0 ]
  then
    echo "\"$dest\" restored."
  else
    echo "Could not restore \"$dest\" from \"$trash\"." && exit 1
  fi
}


case $1 in
  --restore|-r)  # create untrash command
    if [ "$2" = "last" ]
    then
      n="$3" && trash_restore_last "$n"
    else
      id="$2" && trash_restore "$id"
    fi ;;
  --list|-l) trash_list ;;
  --empty|-e) trash_empty ;;
  --put|-p) shift && trash_put $@ ;;
  *) [ ! -z "$1" ] && trash_put $@ || echo "No arguments given." ;;
esac
